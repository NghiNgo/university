Tất nhiên, đây là code C++ cho Bài tập 3.1.

Tôi đã triển khai cả 7 yêu cầu, mỗi yêu cầu đều có 2 phiên bản: **Không đệ quy (Iterative)** dùng vòng lặp và **Đệ quy (Recursive)**. Các hàm đệ quy đều được chú thích rõ **Phần cơ sở (Base Case)** và **Phần đệ quy (Recursive Step)**.

```cpp
/*
 * Giai Bai tap 3.1: De quy va Khong De quy
 * Minh hoa cac ham tinh toan co ban.
 */
#include <iostream>
#include <math.h> // De dung ham sqrt() trong ham IsPrime

using namespace std;

// ===================================================================
// a. f(x, n) = x^n
// ===================================================================

/**
 * @brief Tinh x^n (Khong de quy - Iterative)
 * Su dung vong lap for.
 */
double Power_Iterative(double x, int n) {
    double result = 1.0;
    
    // Xu ly truong hop so mu am
    if (n < 0) {
        x = 1.0 / x; // x^-n = (1/x)^n
        n = -n;
    }
    
    for (int i = 0; i < n; i++) {
        result *= x;
    }
    return result;
}

/**
 * @brief Tinh x^n (De quy - Recursive)
 * Cong thuc:
 * - x^0 = 1         (Phan co so)
 * - x^n = x * x^(n-1) (Phan de quy)
 */
double Power_Recursive(double x, int n) {
    // Phan co so
    if (n == 0) {
        return 1.0;
    }
    
    // Xu ly so mu am
    if (n < 0) {
        return 1.0 / Power_Recursive(x, -n);
    }
    
    // Phan de quy
    return x * Power_Recursive(x, n - 1);
}

// ===================================================================
// b. f(n) = n! (Giai thua)
// ===================================================================

/**
 * @brief Tinh n! (Khong de quy - Iterative)
 */
long long Factorial_Iterative(int n) {
    if (n < 0) return -1; // Loi, giai thua khong xac dinh cho so am
    
    long long result = 1;
    // Vong lap tu 2 den n
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}

/**
 * @brief Tinh n! (De quy - Recursive)
 * Cong thuc tu file KTLT_C02.2_Ham_Coban.pdf
 * - 0! = 1         (Phan co so)
 * - n! = n * (n-1)! (Phan de quy)
 */
long long Factorial_Recursive(int n) {
    if (n < 0) return -1; // Loi
    
    // Phan co so
    if (n == 0) {
        return 1;
    }
    // Phan de quy
    return n * Factorial_Recursive(n - 1);
}

// ===================================================================
// c. s(n) = 1 + 2 + ... + n
// ===================================================================

/**
 * @brief Tinh tong 1 den n (Khong de quy - Iterative)
 */
long long Sum_Iterative(int n) {
    long long total = 0;
    for (int i = 1; i <= n; i++) {
        total += i;
    }
    return total;
}

/**
 * @brief Tinh tong 1 den n (De quy - Recursive)
 * Cong thuc:
 * - s(0) = 0         (Phan co so)
 * - s(n) = n + s(n-1) (Phan de quy)
 */
long long Sum_Recursive(int n) {
    // Phan co so
    if (n == 0) {
        return 0;
    }
    // Phan de quy
    return n + Sum_Recursive(n - 1);
}

// ===================================================================
// d. s(n) = 1 + 3 + 5 + ... + (2n - 1) (Tong n so le dau tien)
// ===================================================================

/**
 * @brief Tinh tong n so le (Khong de quy - Iterative)
 */
long long SumOdd_Iterative(int n) {
    long long total = 0;
    for (int i = 1; i <= n; i++) {
        total += (2 * i - 1);
    }
    // Tip: Ket qua luon la n*n
    return total;
}

/**
 * @brief Tinh tong n so le (De quy - Recursive)
 * Cong thuc:
 * - s(0) = 0             (Phan co so)
 * - s(n) = (2n-1) + s(n-1) (Phan de quy)
 */
long long SumOdd_Recursive(int n) {
    // Phan co so
    if (n == 0) {
        return 0;
    }
    // Phan de quy
    return (2 * n - 1) + SumOdd_Recursive(n - 1);
}

// ===================================================================
// e. s(n) = 2 + 4 + 6 + ... + (2n) (Tong n so chan dau tien)
// ===================================================================

/**
 * @brief Tinh tong n so chan (Khong de quy - Iterative)
 */
long long SumEven_Iterative(int n) {
    long long total = 0;
    for (int i = 1; i <= n; i++) {
        total += (2 * i);
    }
    // Tip: Ket qua luon la n*(n+1)
    return total;
}

/**
 * @brief Tinh tong n so chan (De quy - Recursive)
 * Cong thuc:
 * - s(0) = 0          (Phan co so)
 * - s(n) = 2n + s(n-1) (Phan de quy)
 */
long long SumEven_Recursive(int n) {
    // Phan co so
    if (n == 0) {
        return 0;
    }
    // Phan de quy
    return (2 * n) + SumEven_Recursive(n - 1);
}

// ===================================================================
// f. & g. Ham ho tro kiem tra So Nguyen To
// (Logic tu file MaTran.cpp ban da cung cap)
// ===================================================================

/**
 * @brief Kiem tra 1 so co phai la So Nguyen To
 * @param n So nguyen can kiem tra
 * @return true neu n la SNT, false neu khong phai
 */
bool IsPrime(int n) {
    if (n < 2) return false;
    // Su dung n/2 giong nhu file MaTran.cpp
    // (Toi uu hon la dung sqrt(n))
    for (int i = 2; i <= n / 2; i++) {
        if (n % i == 0) return false;
    }
    return true;
}

// ===================================================================
// f. Tinh tong cac so nguyen to <= n
// ===================================================================

/**
 * @brief Tong SNT <= n (Khong de quy - Iterative)
 */
long long SumPrimes_Iterative(int n) {
    long long total = 0;
    for (int i = 2; i <= n; i++) {
        if (IsPrime(i)) {
            total += i;
        }
    }
    return total;
}

/**
 * @brief Tong SNT <= n (De quy - Recursive)
 * Cong thuc:
 * - s(1) = 0                     (Phan co so)
 * - s(n) = n + s(n-1) neu IsPrime(n)
 * - s(n) = s(n-1)     neu KHONG IsPrime(n)
 */
long long SumPrimes_Recursive(int n) {
    // Phan co so
    if (n < 2) {
        return 0;
    }
    // Phan de quy
    if (IsPrime(n)) {
        return n + SumPrimes_Recursive(n - 1);
    } else {
        return SumPrimes_Recursive(n - 1);
    }
}

// ===================================================================
// g. Dem so nguyen to <= n
// ===================================================================

/**
 * @brief Dem SNT <= n (Khong de quy - Iterative)
 */
int CountPrimes_Iterative(int n) {
    int count = 0;
    for (int i = 2; i <= n; i++) {
        if (IsPrime(i)) {
            count++;
        }
    }
    return count;
}

/**
 * @brief Dem SNT <= n (De quy - Recursive)
 * Cong thuc:
 * - c(1) = 0                     (Phan co so)
 * - c(n) = 1 + c(n-1) neu IsPrime(n)
 * - c(n) = 0 + c(n-1) neu KHONG IsPrime(n)
 */
int CountPrimes_Recursive(int n) {
    // Phan co so
    if (n < 2) {
        return 0;
    }
    // Phan de quy
    if (IsPrime(n)) {
        return 1 + CountPrimes_Recursive(n - 1);
    } else {
        return 0 + CountPrimes_Recursive(n - 1);
    }
}


// ===================================================================
// Ham main de kiem tra
// ===================================================================
int main() {
    int n = 5;
    double x = 2.0;

    cout << "--- a. Tinh x^n (x=2, n=5) ---" << endl;
    cout << "Iterative: " << Power_Iterative(x, n) << endl;
    cout << "Recursive: " << Power_Recursive(x, n) << endl;

    n = 5;
    cout << "\n--- b. Tinh n! (n=5) ---" << endl;
    cout << "Iterative: " << Factorial_Iterative(n) << endl;
    cout << "Recursive: " << Factorial_Recursive(n) << endl;

    n = 10;
    cout << "\n--- c. Tong 1..n (n=10) ---" << endl;
    cout << "Iterative: " << Sum_Iterative(n) << endl;
    cout << "Recursive: " << Sum_Recursive(n) << endl;
    
    n = 5;
    cout << "\n--- d. Tong n so le (n=5) ---" << endl;
    cout << "Iterative: " << SumOdd_Iterative(n) << endl;
    cout << "Recursive: " << SumOdd_Recursive(n) << endl;
    
    n = 5;
    cout << "\n--- e. Tong n so chan (n=5) ---" << endl;
    cout << "Iterative: " << SumEven_Iterative(n) << endl;
    cout << "Recursive: " << SumEven_Recursive(n) << endl;

    n = 11;
    cout << "\n--- f. Tong SNT <= n (n=11) (2+3+5+7+11=28) ---" << endl;
    cout << "Iterative: " << SumPrimes_Iterative(n) << endl;
    cout << "Recursive: " << SumPrimes_Recursive(n) << endl;

    n = 11;
    cout << "\n--- g. Dem SNT <= n (n=11) (2,3,5,7,11 la 5 so) ---" << endl;
    cout << "Iterative: " << CountPrimes_Iterative(n) << endl;
    cout << "Recursive: " << CountPrimes_Recursive(n) << endl;

    return 0;
}
```