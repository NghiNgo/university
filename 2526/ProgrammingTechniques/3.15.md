Ch√†o b·∫°n, ƒë√¢y l√† l·ªùi gi·∫£i chi ti·∫øt cho B√†i t·∫≠p 3.15.

ƒê√¢y l√† m·ªôt b√†i to√°n th√∫ v·ªã, k·∫øt h·ª£p gi·ªØa l·∫≠p tr√¨nh v√† m·ªôt ch√∫t bi·∫øn ƒë·ªïi to√°n h·ªçc. Ch√∫ng ta s·∫Ω gi·∫£i b·∫±ng c·∫£ hai ph∆∞∆°ng ph√°p, v√† t√¥i s·∫Ω gi·∫£i th√≠ch th√™m m·ªôt ph∆∞∆°ng ph√°p th·ª© ba (t·ªëi ∆∞u) d·ª±a tr√™n to√°n h·ªçc.

Ph√¢n t√≠ch b√†i to√°n: $S(n) = \sum_{k=1}^{n} \frac{1}{1+2+3+...+k}$

Ch√∫ng ta bi·∫øt r·∫±ng $1+2+3+...+k = \frac{k \times (k+1)}{2}$.
Do ƒë√≥, m·ªói ph·∫ßn t·ª≠ $\frac{1}{1+2+...+k} = \frac{1}{\frac{k \times (k+1)}{2}} = \frac{2}{k \times (k+1)}$.

-----

### 1\. ‚è© Ph∆∞∆°ng ph√°p Kh√¥ng ƒê·ªá quy (Iterative / V√≤ng l·∫∑p)

Ch√∫ng ta s·∫Ω d√πng m·ªôt v√≤ng l·∫∑p `for` ch·∫°y t·ª´ 1 ƒë·∫øn `n`. Trong m·ªói v√≤ng l·∫∑p, ch√∫ng ta s·∫Ω:

1.  Duy tr√¨ m·ªôt bi·∫øn `denominatorSum` (t·ªïng c·ªßa m·∫´u s·ªë, 1, 3, 6, 10...).
2.  C·ªông ph·∫ßn t·ª≠ `1.0 / denominatorSum` v√†o t·ªïng cu·ªëi c√πng.

<!-- end list -->

```cpp
/**
 * @brief Tinh S(n) (Khong de quy - Iterative)
 * @param n So nguyen duong
 * @return Gia tri S(n)
 */
double S_Iterative(int n) {
    double totalSum = 0.0;
    long long denominatorSum = 0; // De luu 1+2+...+k

    // Vong lap k chay tu 1 den n
    for (int k = 1; k <= n; k++) {
        // Cap nhat tong cua mau so:
        // k=1: denSum = 1
        // k=2: denSum = 1 + 2 = 3
        // k=3: denSum = 3 + 3 = 6
        denominatorSum += k;
        
        // Cong phan tu thu k vao tong
        totalSum += (1.0 / denominatorSum);
    }
    return totalSum;
}
```

-----

### 2\. üîÑ Ph∆∞∆°ng ph√°p ƒê·ªá quy (Recursive)

Ch√∫ng ta ƒë·ªãnh nghƒ©a b√†i to√°n m·ªôt c√°ch ƒë·ªá quy:

  * $S(n) = S(n-1) + \text{Term}(n)$
  * $\text{Term}(n) = \frac{1}{1+2+3+...+n}$

ƒê·ªÉ l√†m ƒëi·ªÅu n√†y, ch√∫ng ta c·∫ßn m·ªôt h√†m ph·ª• ƒë·ªÉ t√≠nh $1+2+...+n$.

```cpp
/**
 * @brief Ham phu (Iterative) de tinh 1+2+...+n
 * (Dung cong thuc cho nhanh)
 */
long long SumToN(int n) {
    return (long long)n * (n + 1) / 2;
}

/**
 * @brief Tinh S(n) (De quy - Recursive)
 * @param n So nguyen duong (n > 0)
 * @return Gia tri S(n)
 */
double S_Recursive(int n) {
    // --- Phan co so (Base Case) ---
    // S(1) = 1 / (1) = 1
    if (n == 1) {
        return 1.0;
    }

    // --- Phan de quy (Recursive Step) ---
    // S(n) = S(n-1) + Term(n)
    
    // 1. Tinh Term(n)
    double term_n = 1.0 / SumToN(n);
    
    // 2. Goi de quy S(n-1)
    double s_n_minus_1 = S_Recursive(n - 1);
    
    // 3. Tra ve tong
    return s_n_minus_1 + term_n;
}
```

-----

### 3\. üí° Ph∆∞∆°ng ph√°p T·ªëi ∆∞u (To√°n h·ªçc)

Nh∆∞ ƒë√£ ph√¢n t√≠ch ·ªü ƒë·∫ßu, b√†i to√°n n√†y l√† m·ªôt chu·ªói l·ªìng nhau (telescoping series):
$S(n) = \sum_{k=1}^{n} \frac{2}{k \times (k+1)} = 2 \times \sum_{k=1}^{n} (\frac{1}{k} - \frac{1}{k+1})$

Khi bung r·ªông ra, t·∫•t c·∫£ c√°c s·ªë ·ªü gi·ªØa s·∫Ω b·ªã tri·ªát ti√™u:
$S(n) = 2 \times [ (1 - \frac{1}{2}) + (\frac{1}{2} - \frac{1}{3}) + ... + (\frac{1}{n} - \frac{1}{n+1}) ]$
$S(n) = 2 \times (1 - \frac{1}{n+1}) = 2 \times (\frac{n}{n+1}) = \frac{2n}{n+1}$

ƒê√¢y l√† c√¥ng th·ª©c t√≠nh tr·ª±c ti·∫øp, hi·ªáu qu·∫£ nh·∫•t.

```cpp
/**
 * @brief Tinh S(n) (Toi uu - Optimized)
 * Su dung bien doi toan hoc S(n) = 2n / (n+1)
 * @param n So nguyen duong
 * @return Gia tri S(n)
 */
double S_Optimized(int n) {
    // Phai dung 2.0 hoac ep kieu de dam bao phep chia la so thuc
    return (2.0 * n) / (n + 1.0);
}
```

-----

### 4\. üñ•Ô∏è Ch∆∞∆°ng tr√¨nh ch√≠nh ƒë·ªÉ ki·ªÉm tra

```cpp
#include <iostream>
#include <iomanip> // De in so thap phan

using namespace std;

// ... (Copy 3 ham S_Iterative, SumToN, S_Recursive, S_Optimized vao day) ...

int main() {
    int n;
    cout << "Nhap n (n > 0): ";
    cin >> n;

    if (n <= 0) {
        cout << "n phai la so duong." << endl;
        return 1;
    }

    // Cau hinh de cout in ra so thap phan voi 6 chu so
    cout << fixed << setprecision(6);

    cout << "\n--- Tinh S(n) voi n = " << n << " ---" << endl;
    
    // Goi ham khong de quy
    cout << "Ket qua (Khong de quy): " << S_Iterative(n) << endl;
    
    // Goi ham de quy
    cout << "Ket qua (De quy):       " << S_Recursive(n) << endl;

    // Goi ham toi uu
    cout << "Ket qua (Toi uu):       " << S_Optimized(n) << endl;

    /*
     * Vi du: n = 3
     * S(3) = 1/(1) + 1/(1+2) + 1/(1+2+3)
     * = 1 + 1/3 + 1/6
     * = 1.0 + 0.333333 + 0.166667 = 1.500000
     *
     * Tinh theo cong thuc toi uu:
     * S(3) = (2 * 3) / (3 + 1) = 6 / 4 = 1.500000
     */
    
    return 0;
}
```