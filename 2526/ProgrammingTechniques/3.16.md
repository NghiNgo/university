Ch√†o b·∫°n, ƒë√¢y l√† l·ªùi gi·∫£i chi ti·∫øt cho B√†i t·∫≠p 3.16.

ƒê√¢y l√† m·ªôt b√†i to√°n t√≠nh t·ªïng l·ªìng nhau. Tr∆∞·ªõc h·∫øt, ch√∫ng ta h√£y ph√¢n t√≠ch b√†i to√°n m·ªôt ch√∫t.

$S(n) = 1 + (1+2) + (1+2+3) + ... + (1+2+3+...+n)$

Ch√∫ng ta c√≥ th·ªÉ vi·∫øt $S(n)$ l√† t·ªïng c·ªßa c√°c $\text{Term}_k$ (ph·∫ßn t·ª≠ th·ª© k):
$S(n) = \sum_{k=1}^{n} \text{Term}_k$

V·ªõi $\text{Term}_k = 1+2+3+...+k = \frac{k \times (k+1)}{2}$

B√†i to√°n tr·ªü th√†nh $S(n) = \sum_{k=1}^{n} \frac{k \times (k+1)}{2}$.

-----

### 1\. ‚è© Ph∆∞∆°ng ph√°p Kh√¥ng ƒê·ªá quy (Iterative / V√≤ng l·∫∑p $O(n)$)

ƒê√¢y l√† c√°ch l·∫≠p tr√¨nh hi·ªáu qu·∫£ v√† d·ªÖ hi·ªÉu. Ch√∫ng ta s·∫Ω d√πng m·ªôt v√≤ng l·∫∑p `for` ch·∫°y t·ª´ 1 ƒë·∫øn `n`. Ch√∫ng ta c·∫ßn 2 bi·∫øn t·ªïng:

1.  `termSum`: ƒê·ªÉ l∆∞u t·ªïng $1+2+...+k$. Bi·∫øn n√†y s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t li√™n t·ª•c.
2.  `totalSum`: ƒê·ªÉ l∆∞u t·ªïng $S(n)$.

<!-- end list -->

```cpp
/**
 * @brief Tinh S(n) (Khong de quy - Iterative)
 * @param n So nguyen duong
 * @return Gia tri S(n)
 */
long long S_Iterative(int n) {
    long long totalSum = 0;       // Ket qua cuoi cung S(n)
    long long termSum = 0;        // De luu 1+2+...+k

    // Vong lap k chay tu 1 den n
    for (int k = 1; k <= n; k++) {
        // Cap nhat tong cua phan tu thu k:
        // k=1: termSum = 0 + 1 = 1
        // k=2: termSum = 1 + 2 = 3
        // k=3: termSum = 3 + 3 = 6
        termSum += k;
        
        // Cong phan tu thu k vao tong cuoi cung
        // S(1) = 0 + 1 = 1
        // S(2) = 1 + 3 = 4
        // S(3) = 4 + 6 = 10
        totalSum += termSum;
    }
    return totalSum;
}
```

-----

### 2\. üîÑ Ph∆∞∆°ng ph√°p ƒê·ªá quy (Recursive)

Ch√∫ng ta ƒë·ªãnh nghƒ©a $S(n)$ d·ª±a tr√™n $S(n-1)$:

  * $S(n) = S(n-1) + \text{Term}(n)$
  * $S(n) = S(n-1) + (1+2+3+...+n)$

Ch√∫ng ta s·∫Ω s·ª≠ d·ª•ng c√¥ng th·ª©c $\text{Term}(n) = \frac{n \times (n+1)}{2}$ ƒë·ªÉ t√≠nh $\text{Term}(n)$ cho nhanh.

```cpp
/**
 * @brief Tinh S(n) (De quy - Recursive)
 * @param n So nguyen duong
 * @return Gia tri S(n)
 */
long long S_Recursive(int n) {
    // --- Phan co so (Base Case) ---
    // S(0) = 0 (khong co phan tu nao de tinh)
    // S(1) = 1
    // Ta co the chon S(1) = 1 lam base case
    if (n == 1) {
        return 1;
    }
    // Hoac S(0) = 0
    if (n <= 0) {
        return 0;
    }

    // --- Phan de quy (Recursive Step) ---
    // S(n) = S(n-1) + Term(n)
    
    // 1. Tinh Term(n) = 1+2+...+n
    long long term_n = (long long)n * (n + 1) / 2;
    
    // 2. Goi de quy S(n-1)
    long long s_n_minus_1 = S_Recursive(n - 1);
    
    // 3. Tra ve tong
    return s_n_minus_1 + term_n;
}
```

-----

### 3\. üí° Ph∆∞∆°ng ph√°p T·ªëi ∆∞u (To√°n h·ªçc $O(1)$)

T·ª´ ph√¢n t√≠ch to√°n h·ªçc ·ªü ƒë·∫ßu:
$S(n) = \sum_{k=1}^{n} \frac{k(k+1)}{2} = \frac{1}{2} \times \sum_{k=1}^{n} (k^2 + k)$

S·ª≠ d·ª•ng c√¥ng th·ª©c t·ªïng c√°c s·ªë v√† t·ªïng c√°c b√¨nh ph∆∞∆°ng:
$S(n) = \frac{1}{2} \times [ \frac{n(n+1)(2n+1)}{6} + \frac{n(n+1)}{2} ]$

Sau khi r√∫t g·ªçn (nh∆∞ trong ph·∫ßn ph√¢n t√≠ch c·ªßa t√¥i), ta c√≥ m·ªôt c√¥ng th·ª©c r·∫•t ƒë·∫πp:
$S(n) = \frac{n \times (n+1) \times (n+2)}{6}$

ƒê√¢y l√† ph∆∞∆°ng ph√°p t√≠nh nhanh nh·∫•t (ƒë·ªô ph·ª©c t·∫°p $O(1)$).

```cpp
/**
 * @brief Tinh S(n) (Toi uu - Optimized)
 * Su dung bien doi toan hoc S(n) = n*(n+1)*(n+2) / 6
 * @param n So nguyen duong
 * @return Gia tri S(n)
 */
long long S_Optimized(int n) {
    // Su dung kieu long long de tranh tran so khi nhan
    return (long long)n * (n + 1) * (n + 2) / 6;
}
```

-----

### 4\. üñ•Ô∏è Ch∆∞∆°ng tr√¨nh ch√≠nh ƒë·ªÉ ki·ªÉm tra

```cpp
#include <iostream>

using namespace std;

// ... (Copy 3 ham S_Iterative, S_Recursive, S_Optimized vao day) ...

int main() {
    int n;
    cout << "Nhap n (n > 0): ";
    cin >> n;

    if (n <= 0) {
        cout << "n phai la so duong." << endl;
        return 1;
    }

    cout << "\n--- Tinh S(n) voi n = " << n << " ---" << endl;
    
    // Goi ham khong de quy
    cout << "Ket qua (Khong de quy): " << S_Iterative(n) << endl;
    
    // Goi ham de quy
    cout << "Ket qua (De quy):       " << S_Recursive(n) << endl;

    // Goi ham toi uu
    cout << "Ket qua (Toi uu):       " << S_Optimized(n) << endl;

    /*
     * Vi du: n = 3
     * S(3) = (1) + (1+2) + (1+2+3)
     * = 1 + 3 + 6 = 10
     *
     * Tinh theo cong thuc toi uu:
     * S(3) = (3 * 4 * 5) / 6 = 60 / 6 = 10
     */
    
    return 0;
}
```