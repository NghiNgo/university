Ch√†o b·∫°n, ƒë√¢y l√† l·ªùi gi·∫£i chi ti·∫øt cho B√†i t·∫≠p 3.2, minh h·ªça c·∫£ hai ph∆∞∆°ng ph√°p.

### 1\. üîÑ Ph∆∞∆°ng ph√°p ƒê·ªá quy (Recursive)

Ph∆∞∆°ng ph√°p n√†y d·ªãch tr·ª±c ti·∫øp c√¥ng th·ª©c ƒë·ªãnh nghƒ©a c·ªßa d√£y Fibonacci th√†nh code. N√≥ r·∫•t r√µ r√†ng v·ªÅ m·∫∑t logic nh∆∞ng kh√¥ng hi·ªáu qu·∫£ v√¨ ph·∫£i t√≠nh to√°n l·∫°i r·∫•t nhi·ªÅu l·∫ßn.

V√≠ d·ª•: ƒê·ªÉ t√≠nh `Fib(5)`, n√≥ s·∫Ω t√≠nh `Fib(4)` v√† `Fib(3)`. ƒê·ªÉ t√≠nh `Fib(4)`, n√≥ *l·∫°i* t√≠nh `Fib(3)` v√† `Fib(2)`. B·∫°n c√≥ th·ªÉ th·∫•y `Fib(3)` b·ªã t√≠nh l·∫∑p l·∫°i nhi·ªÅu l·∫ßn.

```cpp
/**
 * @brief Tinh so Fibonacci thu n (De quy - Recursive)
 * @param n So hang thu n (theo dinh nghia f1, f2 = 1)
 * @return Gia tri cua so Fibonacci thu n
 */
long long Fib_Recursive(int n) {
    // --- Phan co so (Base Case) ---
    // Dinh nghia f1 = 1 va f2 = 1
    // Ta gom ca truong hop n <= 0 tra ve 0 (mac du de bai la n >= 2)
    if (n <= 0) {
        return 0;
    }
    if (n == 1 || n == 2) {
        return 1;
    }

    // --- Phan de quy (Recursive Step) ---
    // fn = fn-1 + fn-2
    return Fib_Recursive(n - 1) + Fib_Recursive(n - 2);
}
```

### 2\. ‚è© Ph∆∞∆°ng ph√°p Kh√¥ng ƒê·ªá quy (Iterative / V√≤ng l·∫∑p)

Ph∆∞∆°ng ph√°p n√†y hi·ªáu qu·∫£ h∆°n r·∫•t nhi·ªÅu. Ch√∫ng ta s·∫Ω d√πng m·ªôt v√≤ng l·∫∑p v√† 3 bi·∫øn (`f1`, `f2`, `fn`) ƒë·ªÉ "x√¢y d·ª±ng" d√£y s·ªë t·ª´ d∆∞·ªõi l√™n, m√¥ ph·ªèng c√°ch b·∫°n vi·∫øt d√£y s·ªë n√†y ra gi·∫•y.

  * `f1` l√† $f_{n-2}$
  * `f2` l√† $f_{n-1}$
  * `fn` l√† $f_n$ (k·∫øt qu·∫£ c·ªßa `f1 + f2`)

Sau m·ªói v√≤ng l·∫∑p, ch√∫ng ta "d·ªãch chuy·ªÉn" c√°c gi√° tr·ªã: `f1` m·ªõi s·∫Ω l√† `f2` c≈©, v√† `f2` m·ªõi s·∫Ω l√† `fn` c≈©.

```cpp
/**
 * @brief Tinh so Fibonacci thu n (Khong de quy - Iterative)
 * @param n So hang thu n
 * @return Gia tri cua so Fibonacci thu n
 */
long long Fib_Iterative(int n) {
    if (n <= 0) {
        return 0;
    }
    if (n == 1 || n == 2) {
        return 1;
    }
    
    // Khoi tao 2 so Fibonacci dau tien
    long long f1 = 1; // Tuong ung f(n-2)
    long long f2 = 1; // Tuong ung f(n-1)
    long long fn = 0; // Tuong ung f(n)
    
    // Bat dau tinh tu n = 3
    // Vong lap se chay tu 3 den n
    for (int i = 3; i <= n; i++) {
        // Tinh fn = fn-1 + fn-2
        fn = f1 + f2;
        
        // "Dich chuyen" cac bien de chuan bi cho vong lap tiep theo
        f1 = f2; // f(n-2) cua buoc sau = f(n-1) cua buoc nay
        f2 = fn; // f(n-1) cua buoc sau = f(n) cua buoc nay
    }
    
    return fn; // fn luc nay la f(n) can tim
}
```

### 3\. üñ•Ô∏è Ch∆∞∆°ng tr√¨nh ch√≠nh ƒë·ªÉ ki·ªÉm tra

ƒê√¢y l√† h√†m `main` ƒë·ªÉ b·∫°n ch·∫°y th·ª≠ c·∫£ hai ph∆∞∆°ng ph√°p. B·∫°n s·∫Ω th·∫•y ph∆∞∆°ng ph√°p ƒë·ªá quy ch·∫°y r·∫•t ch·∫≠m khi `n` l·ªõn (v√≠ d·ª• `n = 45`), trong khi ph∆∞∆°ng ph√°p v√≤ng l·∫∑p cho k·∫øt qu·∫£ ngay l·∫≠p t·ª©c.

```cpp
#include <iostream>

using namespace std;

// ... (Copy 2 ham Fib_Recursive va Fib_Iterative vao day) ...

int main() {
    int n;
    cout << "Nhap so hang n can tim: ";
    cin >> n;

    cout << "\n--- Phuong phap Khong De Quy (Iterative) ---" << endl;
    cout << "f(" << n << ") = " << Fib_Iterative(n) << endl;
    
    cout << "\n--- Phuong phap De Quy (Recursive) ---" << endl;
    cout << "(Phuong phap nay co the chay rat cham neu n > 40)" << endl;
    cout << "f(" << n << ") = " << Fib_Recursive(n) << endl;

    return 0;
}
```